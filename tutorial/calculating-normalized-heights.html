


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Calculating Normalized Heights &mdash; pdal.io</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
  

  
        <link rel="author" title="About these documents"
              href="../about.html"/>
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="pdal.io" href="../index.html"/>
        <link rel="up" title="Tutorials" href="index.html"/>
        <link rel="next" title="Performing Poisson Sampling of Point Clouds Using Dart Throwing" href="dart-throwing.html"/>
        <link rel="prev" title="Clipping with Geometries" href="clipping-with-shapefile.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PDAL
          

          
          </a>

          
            
            
              <div class="version">
                1.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../apps/index.html">Applications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pipeline.html">Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/readers.html">Readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/writers.html">Writers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/filters.html">Filters</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dimensions.html">Dimensions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python.html">Python</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#using-pdal">Using PDAL</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="reading.html">Reading with PDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing.html">Writing with PDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="las.html">LAS Reading and Writing with PDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcl_block_tutorial.html">Filtering data with PCL</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcl_ground.html">Identifying ground returns using ProgressiveMorphologicalFilter segmentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="clipping-with-shapefile.html">Clipping with Geometries</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Calculating Normalized Heights</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#approach">Approach</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-1">Example #1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-2">Example #2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-3">Example #3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dart-throwing.html">Performing Poisson Sampling of Point Clouds Using Dart Throwing</a></li>
<li class="toctree-l3"><a class="reference internal" href="python-filtering.html">Filtering Data with Python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#developing">Developing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../workshop/index.html">Workshop</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">PDAL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Home</a> &raquo;</li>
      
        <li><a href="index.html">Tutorials</a> &raquo;</li>
      
    <li>Calculating Normalized Heights</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="calculating-normalized-heights">
<h1>Calculating Normalized Heights<a class="headerlink" href="#calculating-normalized-heights" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Bradley Chambers</td>
</tr>
<tr class="field-even field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference external" href="mailto:brad&#46;chambers&#37;&#52;&#48;gmail&#46;com">brad<span>&#46;</span>chambers<span>&#64;</span>gmail<span>&#46;</span>com</a></td>
</tr>
<tr class="field-odd field"><th class="field-name">Date:</th><td class="field-body">11/11/2015</td>
</tr>
</tbody>
</table>
<p>This tutorial will describe the creation of a new filter for calculating
normalized heights, <code class="docutils literal"><span class="pre">filters.height</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">filters.height</span></code> required PCL and has since been replaced by
<a class="reference internal" href="../stages/filters.hag.html#filters-hag"><span class="std std-ref">filters.hag</span></a>, which is a native PDAL filter. We leave this tutorial as
an example of how to create a filter, and of how to work with the PCL plugin,
but the filter in reference is no longer available.</p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Normalized heights are a commonly used attribute of point cloud data. This can
also be referred to as <em>height above ground</em> (HAG) or <em>above ground level</em>
(AGL) heights. In the end, it is simply a measure of a point&#8217;s relative height
as opposed to its raw elevation value.</p>
<p>The process of computing normalized heights is straightforward. First, we must
have an estimate of the underlying terrain model. With this we can compute the
difference between each point&#8217;s elevation and the elevation of the terrain
model at the same XY coordinate. The quality of the normalized heights will be
a function of the quality of the terrain model, which of course depends on the
quality of the ground segmentation approach and any interpolation that is
required to arrive at the terrain elevation for a given XY coordinate.</p>
<p>We will use a nearest neighbor interpolation scheme to estimate terrain
elevations. While this may not be the most accurate approach, it is available
in PDAL today, and we hope it will inspire you to implement your own methods!</p>
</div>
<div class="section" id="approach">
<h2>Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h2>
<p>For the height filter, we only assume that our input point cloud has an already
existing <code class="docutils literal"><span class="pre">Classification</span></code> dimension with some subset of points marked as
ground (<code class="docutils literal"><span class="pre">Classification=2</span></code>). This could, for example, be generated by
<a class="reference internal" href="../stages/filters.pmf.html#filters-pmf"><span class="std std-ref">filters.pmf</span></a> (see <a class="reference internal" href="pcl_ground.html#pcl-ground"><span class="std std-ref">Identifying ground returns using ProgressiveMorphologicalFilter segmentation</span></a>), but you can use whichever method
you choose, as long as the ground returns are marked.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We expect ground returns to have the classification value of 2 in keeping with the ASPRS Standard LIDAR Point Classes (see <a class="reference external" href="http://www.asprs.org/a/society/committees/standards/LAS_1_4_r13.pdf">http://www.asprs.org/a/society/committees/standards/LAS_1_4_r13.pdf</a>).</p>
</div>
<p>For the full source, please see <code class="docutils literal"><span class="pre">HeightFilter.cpp</span></code> in the
<code class="docutils literal"><span class="pre">plugins/pcl/filters</span></code> folder. Below, we dissect the key aspects of the
algorithm and its implementation.</p>
<p>The bulk of our processing is actually taking place within PCL. For
convenience, we&#8217;ve defined:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">Cloud</span><span class="p">;</span>
</pre></div>
</div>
<p>Our first step is to convert the filter&#8217;s incoming PDAL <code class="docutils literal"><span class="pre">PointView</span></code> to a PCL
<code class="docutils literal"><span class="pre">PointCloud</span></code>, which requires that we first calculate our bounds so that we
can subtract our XYZ offsets in the conversion step.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">BOX3D</span> <span class="n">bounds</span><span class="p">;</span>
<span class="n">view</span><span class="p">.</span><span class="n">calculateBounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">);</span>

<span class="n">Cloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">cloud_in</span><span class="p">(</span><span class="k">new</span> <span class="n">Cloud</span><span class="p">);</span>
<span class="n">pclsupport</span><span class="o">::</span><span class="n">PDALtoPCD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">PointView</span><span class="o">&gt;</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="o">*</span><span class="n">cloud_in</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we will create two vectors of indices - one for ground returns, one for
non-ground returns - and make our first pass through the point cloud to
populate these.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">pcl</span><span class="o">::</span><span class="n">PointIndices</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">ground</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointIndices</span><span class="p">());</span>
<span class="n">ground</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointId</span><span class="o">&gt;</span> <span class="n">nonground</span><span class="p">;</span>
<span class="n">nonground</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="k">for</span> <span class="p">(</span><span class="n">PointId</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">view</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="o">::</span><span class="n">Id</span><span class="o">::</span><span class="n">Classification</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ground</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">nonground</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With our ground indices identified, we can use PCL to extract the ground
returns into a new <code class="docutils literal"><span class="pre">PointCloud</span></code>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">pcl</span><span class="o">::</span><span class="n">ExtractIndices</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">extract</span><span class="p">;</span>
<span class="n">extract</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud_in</span><span class="p">);</span>
<span class="n">extract</span><span class="p">.</span><span class="n">setIndices</span><span class="p">(</span><span class="n">ground</span><span class="p">);</span>

<span class="n">Cloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">cloud_ground</span><span class="p">(</span><span class="k">new</span> <span class="n">Cloud</span><span class="p">);</span>
<span class="n">extract</span><span class="p">.</span><span class="n">setNegative</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">extract</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_ground</span><span class="p">);</span>
</pre></div>
</div>
<p>We repeat the extraction now, flipping <code class="docutils literal"><span class="pre">setNegative</span></code> from false to true to
extract the non-ground returns into a new <code class="docutils literal"><span class="pre">PointCloud</span></code>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Cloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">cloud_nonground</span><span class="p">(</span><span class="k">new</span> <span class="n">Cloud</span><span class="p">);</span>
<span class="n">extract</span><span class="p">.</span><span class="n">setNegative</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">extract</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_nonground</span><span class="p">);</span>
</pre></div>
</div>
<p>To compute the normalized height, we wish to find the nearest ground point for
each non-ground point. Here, we achieve this by using a nearest neighbor
interpolation scheme. One may prefer to use a more sophisticated interpolation
scheme, but that is beyond the scope of this tutorial. We begin by defining
model coefficients that will allow us to project the ground and non-ground
clouds into the XY plane.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">pcl</span><span class="o">::</span><span class="n">ModelCoefficients</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">coefficients</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ModelCoefficients</span><span class="p">());</span>
<span class="n">coefficients</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">coefficients</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">coefficients</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="n">coefficients</span><span class="o">-&gt;</span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>We can now project the ground points</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">pcl</span><span class="o">::</span><span class="n">ProjectInliers</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">proj</span><span class="p">;</span>
<span class="n">proj</span><span class="p">.</span><span class="n">setModelType</span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">SACMODEL_PLANE</span><span class="p">);</span>

<span class="n">Cloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">cloud_ground_projected</span><span class="p">(</span><span class="k">new</span> <span class="n">Cloud</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud_ground</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">setModelCoefficients</span><span class="p">(</span><span class="n">coefficients</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_ground_projected</span><span class="p">);</span>
</pre></div>
</div>
<p>followed by the non-ground points</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">Cloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">cloud_nonground_projected</span><span class="p">(</span><span class="k">new</span> <span class="n">Cloud</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud_nonground</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">setModelCoefficients</span><span class="p">(</span><span class="n">coefficients</span><span class="p">);</span>
<span class="n">proj</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_nonground_projected</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we create a KdTree to accelerate our nearest neighbor search. The tree is
composed of only ground returns, as our non-ground returns will serve as query
points for the nearest neighbor search.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">ground_tree</span><span class="p">;</span>
<span class="n">ground_tree</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">(</span><span class="nb">false</span><span class="p">));</span>
<span class="n">ground_tree</span><span class="o">-&gt;</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud_ground_projected</span><span class="p">);</span>
</pre></div>
</div>
<p>We iterate over each of our projected non-ground points, searching for our
nearest neighbor in the ground points. Using the indices of each the query
(non-ground) and nearest neighbor (ground), we can retrieve the Z dimension
from the input cloud, compute the height, and set this field in our original
<code class="docutils literal"><span class="pre">PointView</span></code>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cloud_nonground_projected</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span> <span class="n">nonground_query</span> <span class="o">=</span> <span class="n">cloud_nonground_projected</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">neighbors</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sqr_distances</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">ground_tree</span><span class="o">-&gt;</span><span class="n">nearestKSearch</span><span class="p">(</span><span class="n">nonground_query</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">sqr_distances</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">nonground_Z</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="o">::</span><span class="n">Id</span><span class="o">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">nonground</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="kt">double</span> <span class="n">ground_Z</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="o">::</span><span class="n">Id</span><span class="o">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">ground</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
    <span class="kt">double</span> <span class="n">height</span> <span class="o">=</span> <span class="n">nonground_Z</span> <span class="o">-</span> <span class="n">ground_Z</span><span class="p">;</span>

    <span class="n">view</span><span class="p">.</span><span class="n">setField</span><span class="p">(</span><span class="n">m_heightDim</span><span class="p">,</span> <span class="n">nonground</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">height</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only thing left is to set the height field to 0.0 for each of the ground points.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">ground_idx</span> <span class="p">:</span> <span class="n">ground</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">view</span><span class="p">.</span><span class="n">setField</span><span class="p">(</span><span class="n">m_heightDim</span><span class="p">,</span> <span class="n">ground_idx</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="example-1">
<h2>Example #1<a class="headerlink" href="#example-1" title="Permalink to this headline">¶</a></h2>
<p>Using the autzen dataset (here shown colored by elevation)</p>
<a class="reference internal image-reference" href="../_images/autzen-elevation.png"><img alt="../_images/autzen-elevation.png" src="../_images/autzen-elevation.png" style="height: 400px;" /></a>
<p>we run the following PDAL CLI command</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ pdal translate autzen.laz autzen-height.bpf height \
  --writers.bpf.output_dims=&quot;X,Y,Z,HeightAboveGround&quot;
</pre></div>
</div>
<p>The result, when colored by the normalized height instead of elevation is</p>
<a class="reference internal image-reference" href="../_images/autzen-height.png"><img alt="../_images/autzen-height.png" src="../_images/autzen-height.png" style="height: 400px;" /></a>
</div>
<div class="section" id="example-2">
<h2>Example #2<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h2>
<p>If you&#8217;d like to overwrite your Z values, follow the height filter with <a class="reference internal" href="../stages/filters.ferry.html#filters-ferry"><span class="std std-ref">filters.ferry</span></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ pdal translate input.laz output-height-as-Z.bpf height ferry \
  --writers.bpf.output_dims=&quot;X,Y,Z&quot; --filters.ferry.dimensions=&quot;HeightAboveGround=Z&quot;
</pre></div>
</div>
</div>
<div class="section" id="example-3">
<h2>Example #3<a class="headerlink" href="#example-3" title="Permalink to this headline">¶</a></h2>
<p>If you don&#8217;t yet have points classified as ground, start with <a class="reference internal" href="../stages/filters.pmf.html#filters-pmf"><span class="std std-ref">filters.pmf</span></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ pdal translate input.laz output-ground-height.bpf ground height \
  --writers.bpf.output_dims=&quot;X,Y,Z,HeightAboveGround&quot;
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dart-throwing.html" class="btn btn-neutral float-right" title="Performing Poisson Sampling of Point Clouds Using Dart Throwing" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="clipping-with-shapefile.html" class="btn btn-neutral" title="Clipping with Geometries" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
                    &copy;  2017
                        <a href="http://github.com/hobu">Howard Butler</a>,
                        <a href="http://github.com/mpgerlek">Michael Gerlek</a>,
                        and
                        <a href="https://github.com/PDAL/PDAL/graphs/contributors">others</a>.
      Last updated on Jul 21, 2017.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
    <div class="footer">
        <div class="container">
                    &copy;  2017
                        <a href="http://github.com/hobu">Howard Butler</a>,
                        <a href="http://github.com/mpgerlek">Michael Gerlek</a>,
                        and
                        <a href="https://github.com/PDAL/PDAL/graphs/contributors">others</a>,
                Last updated
                    on Jul 21, 2017.
        </div>
    </div>

</body>
</html>